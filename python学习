2018.4.12
1.任何一种语言都有自己的一套语法，编译器或者解释器就是负责把符合语法的程序代码转换成cpu能够执行的机器码，然后执行。
2.python大小写敏感，最好使用4个空格缩进。
3.浮点数也就是小数，之所以称为浮点数，是因为按照科学计数法表示时，一个浮点数的小数点是可变的；整数和浮点数在计算机内部的存储方式是不同的，整数永远是精确的（除法也是），而浮点运算则可能会有四舍五入的误差。
4.如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用'''...'''的格式表示多行内容.
5.空值是Python里的一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。
6.python变量本身的类型不固定（可把任意类型赋值给变量，同一个变量可以反复赋值），称为动态语言；与之对应是静态语言如Java（定义变量时必须指定变量类型，赋值时类型不匹配就会报错）。
7.Python中整数除法为什么也是精确的？
答：在pyton中，两种除法：a. 10/3  = 3.3333333   9/3 = 3.0 计算结果是浮点数
					b. 10//3 = 3 地板除，永远是整数
					求余 10 % 3 = 1
8.python中整数没有大小限制，浮点数也没有大小限制，超出一定范围表示为inf。
9.字符编码
		a.ASCLL编码是1个字节，而Unicode编码通常是2个字节；
			带来的问题：写的文本基本是英文的话，用Unicode编码比ascll编码需要多一倍的存储空间
		b.为节约产生“可变长编码”UTF-8编码。根据不同的数字大小编码成1-6个字节。
		c.搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：
			1.在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。
			2.用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件
			3.浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器,所以你看到很多网页的源码上会有类似<meta charset="UTF-8" />的信息，表示该网页正是用的UTF-8编码
		d.对于单个字符的编码，Python提供了ord（）函数获取字符的整数表示，chr()把编码转换为对应字符    ord('A')  65    chr(66)  'B'
		e.由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。
			注意区分‘ABC’ 和 b‘ABC’,前者是str，后者是bytes;bytes的每个字符都只占用一个字节；
			以Unicode表示的str通过encode()方法可以编码为指定的bytes 如:
				>>> 'ABC'.encode('ascii')    b'ABC'
				>>>'中文'.encode('utf-8')    b'\xe4\xb8\xad\xe6\x96\x87'
			如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：
				>>> b'ABC'.decode('ascii')
				'ABC'
				>>> b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
				'中文'
		f.len()函数计算的是str的字节数，如果换成bytes,len()
		g.输出格式化的字符串：字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%
			>>> 'growth rate: %d %%' % 7
				'growth rate: 7 %'
			另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}
				>>> 'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)
					'Hello, 小明, 成绩提升了 17.1%'
10.不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。
	当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来
	如果可能，能用tuple代替list就尽量用tuple。
	只有1个元素的tuple定义时必须加一个逗号,>>> t = (1,)
11.要特别注意，不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。
12.请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。
dict的key必须是不可变对象;在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key.

和list比较，dict有以下几个特点：
查找和插入的速度极快，不会随着key的增加而变慢；
需要占用大量的内存，内存浪费多。

而list相反：
查找和插入的时间随着元素的增加而增加；
占用空间小，浪费内存很少。
所以，dict是用空间来换取时间的一种方法。
13.要创建一个set，需要提供一个list作为输入集合,s = set([1, 2, 3]),在set中，没有重复的key;
对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。
14.可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。
写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。
15.函数执行完毕也没有return语句时，自动return None。

函数可以同时返回多个值，但其实就是一个tuple。
16.新的power(x, n)函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用.
这时使用默认参数 def power(x, n=2)

默认参数可以简化函数的调用。设置默认参数时，有几点要注意：

一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；
二是如何设置默认参数。
当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。
使用默认参数有什么好处？最大的好处是能降低调用函数的难度。

定义默认参数要牢记一点：默认参数必须指向不变对象！
def add_end(L=[]):
    L.append('END')
    return L
>>> add_end()
['END']
>>> add_end()
['END', 'END']
>>> add_end()
['END', 'END', 'END']
Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。

def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L
为什么要设计str、None这样的不变对象呢？
	因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。

17.可变参数
可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。
	*nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。
	def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
18.关键字参数
def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)
>>> person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}

>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
>>> person('Jack', 24, city=extra['city'], job=extra['job'])
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}

>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
>>> person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}

关键字参数有什么用？
它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。
19.命名关键字参数
	如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：
def person(name, age, *, city, job):
    print(name, age, city, job)
>>> person('Jack', 24, city='Beijing', job='Engineer')
Jack 24 Beijing Engineer
和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。

如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：
def person(name, age, *args, city, job):
    print(name, age, args, city, job)
命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：

命名关键字参数可以有缺省值，从而简化调用
def person(name, age, *, city='Beijing', job):


20.参数组合
在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。
虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。
对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。

21.小结
Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。

默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！

要注意定义可变参数和关键字参数的语法：

*args是可变参数，args接收的是一个tuple；

**kw是关键字参数，kw接收的是一个dict。

以及调用函数时如何传入可变参数和关键字参数的语法：

可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；

关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。

使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。

命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。

定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。
22.递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。
def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)
使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。

解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。

尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式.
def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。
23.当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。

那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断：
如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)
...
0 A
1 B
2 C
24.在Python中，这种一边循环一边计算的机制，称为生成器：generator。
第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：

>>> L = [x * x for x in range(10)]
>>> L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> g = (x * x for x in range(10))
>>> g
<generator object <genexpr> at 0x1022ef630>
如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：

>>> next(g)
0
我们创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，

这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：
请注意区分普通函数和generator函数，普通函数调用直接返回结果：
generator函数的“调用”实际返回一个generator对象：
25.我们已经知道，可以直接作用于for循环的数据类型有以下几种：

一类是集合数据类型，如list、tuple、dict、set、str等；

一类是generator，包括生成器和带yield的generator function。

这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。

可以使用isinstance()判断一个对象是否是Iterable对象：

>>> from collections import Iterable
>>> isinstance([], Iterable)
True

26.凡是可作用于for循环的对象都是Iterable类型；

凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；

集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。

Python的for循环本质上就是通过不断调用next()函数实现的


2018.4.13

1.函数式编程
	函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量。
	函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数。
	高阶函数：
		1.map/reduce
		map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。
		
		reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：
		reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
>>> def f(x):
...    return x * x
...
>>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]

>>> from functools import reduce
>>> def fn(x, y):
...     return x * 10 + y
...
>>> reduce(fn, [1, 3, 5, 7, 9])
13579
		2.Python内建的filter()函数用于过滤序列。

		和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。
			def is_odd(n):
    			return n % 2 == 1

			list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
			
	# 结果: [1, 5, 9, 15]
找回数：
def is_palindrome(n):
    return str(n) == str(n)[::-1]

output = filter(is_palindrome, range(1, 1000))
print('1~1000:', list(output))
if list(filter(is_palindrome, range(1, 200))) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191]:
    print('测试成功!')
else:
    print('测试失败!')	


s='123'
s[::-1] = '321'

sorted()函数
sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)
['about', 'bob', 'Credit', 'Zoo']
>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']













