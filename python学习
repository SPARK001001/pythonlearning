2018.4.12
1.任何一种语言都有自己的一套语法，编译器或者解释器就是负责把符合语法的程序代码转换成cpu能够执行的机器码，然后执行。
2.python大小写敏感，最好使用4个空格缩进。
3.浮点数也就是小数，之所以称为浮点数，是因为按照科学计数法表示时，一个浮点数的小数点是可变的；整数和浮点数在计算机内部的存储方式是不同的，整数永远是精确的（除法也是），而浮点运算则可能会有四舍五入的误差。
4.如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用'''...'''的格式表示多行内容.
5.空值是Python里的一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。
6.python变量本身的类型不固定（可把任意类型赋值给变量，同一个变量可以反复赋值），称为动态语言；与之对应是静态语言如Java（定义变量时必须指定变量类型，赋值时类型不匹配就会报错）。
7.Python中整数除法为什么也是精确的？
答：在pyton中，两种除法：a. 10/3  = 3.3333333   9/3 = 3.0 计算结果是浮点数
					b. 10//3 = 3 地板除，永远是整数
					求余 10 % 3 = 1
8.python中整数没有大小限制，浮点数也没有大小限制，超出一定范围表示为inf。
9.字符编码
		a.ASCLL编码是1个字节，而Unicode编码通常是2个字节；
			带来的问题：写的文本基本是英文的话，用Unicode编码比ascll编码需要多一倍的存储空间
		b.为节约产生“可变长编码”UTF-8编码。根据不同的数字大小编码成1-6个字节。
		c.搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：
			1.在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。
			2.用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件
			3.浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器,所以你看到很多网页的源码上会有类似<meta charset="UTF-8" />的信息，表示该网页正是用的UTF-8编码
		d.对于单个字符的编码，Python提供了ord（）函数获取字符的整数表示，chr()把编码转换为对应字符    ord('A')  65    chr(66)  'B'
		e.由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。
			注意区分‘ABC’ 和 b‘ABC’,前者是str，后者是bytes;bytes的每个字符都只占用一个字节；
			以Unicode表示的str通过encode()方法可以编码为指定的bytes 如:
				>>> 'ABC'.encode('ascii')    b'ABC'
				>>>'中文'.encode('utf-8')    b'\xe4\xb8\xad\xe6\x96\x87'
			如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：
				>>> b'ABC'.decode('ascii')
				'ABC'
				>>> b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
				'中文'
		f.len()函数计算的是str的字节数，如果换成bytes,len()
		g.输出格式化的字符串：字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%
			>>> 'growth rate: %d %%' % 7
				'growth rate: 7 %'
			另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}
				>>> 'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)
					'Hello, 小明, 成绩提升了 17.1%'
10.不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。
	当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来
	如果可能，能用tuple代替list就尽量用tuple。
	只有1个元素的tuple定义时必须加一个逗号,>>> t = (1,)
11.要特别注意，不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。
12.请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。
dict的key必须是不可变对象;在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key.

和list比较，dict有以下几个特点：
查找和插入的速度极快，不会随着key的增加而变慢；
需要占用大量的内存，内存浪费多。

而list相反：
查找和插入的时间随着元素的增加而增加；
占用空间小，浪费内存很少。
所以，dict是用空间来换取时间的一种方法。
13.要创建一个set，需要提供一个list作为输入集合,s = set([1, 2, 3]),在set中，没有重复的key;
对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。
14.可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。
写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。
15.函数执行完毕也没有return语句时，自动return None。

函数可以同时返回多个值，但其实就是一个tuple。
16.新的power(x, n)函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用.
这时使用默认参数 def power(x, n=2)

默认参数可以简化函数的调用。设置默认参数时，有几点要注意：

一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；
二是如何设置默认参数。
当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。
使用默认参数有什么好处？最大的好处是能降低调用函数的难度。

定义默认参数要牢记一点：默认参数必须指向不变对象！
def add_end(L=[]):
    L.append('END')
    return L
>>> add_end()
['END']
>>> add_end()
['END', 'END']
>>> add_end()
['END', 'END', 'END']
Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。

def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L
为什么要设计str、None这样的不变对象呢？
	因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。

17.可变参数
可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。
	*nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。
	def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
18.关键字参数
def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)
>>> person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}

>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
>>> person('Jack', 24, city=extra['city'], job=extra['job'])
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}

>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
>>> person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}

关键字参数有什么用？
它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。
19.命名关键字参数
	如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：
def person(name, age, *, city, job):
    print(name, age, city, job)
>>> person('Jack', 24, city='Beijing', job='Engineer')
Jack 24 Beijing Engineer
和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。

如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：
def person(name, age, *args, city, job):
    print(name, age, args, city, job)
命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：

命名关键字参数可以有缺省值，从而简化调用
def person(name, age, *, city='Beijing', job):


20.参数组合
在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。
虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。
对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。

21.小结
Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。

默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！

要注意定义可变参数和关键字参数的语法：

*args是可变参数，args接收的是一个tuple；

**kw是关键字参数，kw接收的是一个dict。

以及调用函数时如何传入可变参数和关键字参数的语法：

可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；

关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。

使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。

命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。

定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。
22.递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。
def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)
使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。

解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。

尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式.
def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。
23.当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。

那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断：
如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)
...
0 A
1 B
2 C
24.在Python中，这种一边循环一边计算的机制，称为生成器：generator。
第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：

>>> L = [x * x for x in range(10)]
>>> L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> g = (x * x for x in range(10))
>>> g
<generator object <genexpr> at 0x1022ef630>
如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：

>>> next(g)
0
我们创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，

这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：
请注意区分普通函数和generator函数，普通函数调用直接返回结果：
generator函数的“调用”实际返回一个generator对象：
25.我们已经知道，可以直接作用于for循环的数据类型有以下几种：

一类是集合数据类型，如list、tuple、dict、set、str等；

一类是generator，包括生成器和带yield的generator function。

这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。

可以使用isinstance()判断一个对象是否是Iterable对象：

>>> from collections import Iterable
>>> isinstance([], Iterable)
True

26.凡是可作用于for循环的对象都是Iterable类型；

凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；

集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。

Python的for循环本质上就是通过不断调用next()函数实现的


2018.4.13

1.函数式编程
	函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量。
	函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数。
	高阶函数：
		1.map/reduce
		map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。
		
		reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：
		reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
>>> def f(x):
...    return x * x
...
>>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]

>>> from functools import reduce
>>> def fn(x, y):
...     return x * 10 + y
...
>>> reduce(fn, [1, 3, 5, 7, 9])
13579
		2.Python内建的filter()函数用于过滤序列。

		和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。
			def is_odd(n):
    			return n % 2 == 1

			list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
			
	# 结果: [1, 5, 9, 15]
找回数：
def is_palindrome(n):
    return str(n) == str(n)[::-1]

output = filter(is_palindrome, range(1, 1000))
print('1~1000:', list(output))
if list(filter(is_palindrome, range(1, 200))) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191]:
    print('测试成功!')
else:
    print('测试失败!')	


s='123'
s[::-1] = '321'

sorted()函数
orted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)
['about', 'bob', 'Credit', 'Zoo']
>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']



2018.4.16
返回函数   闭包
	不需要立即求和，而是在后面的代码中，根据需要在计算
	def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
    在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的函数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，
    这种程序结构称为“闭包（closure）”
    会发生的问题：
    def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

	f1, f2, f3 = count()

	>>>f1() 9
	>>>f2() 9
	>>>f3() 9
	都是9，原因在于返回的函数引用变量i,但它并非立刻执行，等到3个函数都返回时，他们所引用的变量i已经变成了3，因此最终结果为9.
    返回闭包时，牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量

    如果一定要引用循环变量？再创建一个函数，用该函数的参数绑定循环变量当前的值。
    def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs

    >>> f1, f2, f3 = count()
	>>> f1()
	1
	>>> f2()
	4
	>>> f3()
	9

	利用闭包返回一个计数器函数，每次调用他返回递增整数：
	def createCounter():
    s = [0]
    def counter():
        s[0] += 1
        return s[0]
    return counter

	做些笔记：
	1.内部函数一般无法修改外部函数的参数
	2.想要修改需要声明 nonlocal
	3.内部函数可以修改外部list中的元素

2.匿名函数
	匿名函数labmda x: x * x 实际上就是
	def f(x):
		return x * x
	冒号前x表示函数参数；
	限制：只能有一个表达式，不用写return，返回值就是该表达式的结果
	好处：函数没名字，不用担心函数名冲突；匿名函数也是一个函数对象。

3.装饰器
	要增加函数的功能，又不想修改函数的定义，这种在代码运行期间动态增加功能的方式，称为“装饰器”（Decorator）

一个完整的decorator的写法如下：
import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper


针对带参数的decorator：
import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)#不加这一行的话调用now.__name__ 会显示wrapper,而不会显示now
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator

@log('execute')
def now():
    print('2015-3-25')

>>> now()
execute now():
2015-3-25

4.偏函数
	通过设定函数的默认值，可以降低调用函数的难度，偏函数也可以做到这一点；
	functools.partial 就是帮助我们创建一个偏函数的。作用就是把一个函数的某些参数给固定住（也就是设置默认值，）
	返回一个新的函数，调用这个新函数会更简单。
	创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数，
	当传入int2 = functools.partial(int, base=2)
	int2('10010')
	kw = { 'base': 2 }
	int('10010', **kw)
	当传入max2 = functools.partial(max, 10)实际上会把10作为*args的一部分自动加到左边
	也就是max2(5, 6, 7)相当于args = (10, 5, 6, 7)
	max(*args) 结果为10

	当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。
	
2018.4.17
1.模块：
	提高代码的课维护性；编写代码不必从零开始。
	可以避免函数名和变量名冲突。但也要避免与内置函数名字冲突。（如系统自带sys模块，自己命名的模块就不可命名为sys.py，否则无法导入系统自带的sys模块）
	为避免模块名冲突，Python引入按目录来组织模块的方法，称为”包“package。
	注意，每一个包目录下都会有一个__init__.py的文件，这个文件必须存在，否则Python就把这个目录当成普通目录，而不是一个包。__init__.py本身是一个模块，他的模块名就是包名

	创建自己的模块时，要注意：
		模块名要遵循Python变量命名规范，不要使用中文、特殊字符；
		模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行import abc，若成功则说明系统存在此模块。
	作用域：
		在Python中是通过_前缀来实现的private的
		类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途。
	安装第三方模块：
		pip install Pillow
		第三方库都会在Python官方的pypi.python.org网站注册
		默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块，和第三方模块，搜索路径存放在sys模块的path变量中：
		import sys  sys.path
		要添加自己的搜索目录，两种方法：
			直接修改sys.path
					import sys
					sys.path.append('/')
					在运行时修改，运行结束后失效
			设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。
2.面向对象编程OOP 封装 继承 多态
	面向过程的程序吧计算机程序视为一系列命令集合，即一组函数的顺序执行，为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数切割成小块函数来降低系统的复杂度。
	面向对象程序设计吧计算机程序视为一组对象的集合，而每个对象可以接收其他对象发过来的消息，并处理这些消息，计算机程序执行的就是一系列消息在各个对象之间的传递。
	给对象发消息就是调用对象对应的关联函数，，我们称之为对象的方法。
	面向对象的设计思想是抽象出class，根据class创建instance。
	类和实例：
		类可以起到模板的作用，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去，通过定义一个特殊的__init__方法。（两个下划线）
		和普通函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，但调用时，不用传递该参数。除此外，与普通函数美什么区别。仍可以用默认参数，可变参数，关键字参数，和命名关键字参数
		封装：
			好处：数据和逻辑被封装，调用容易，不需要知道内部实现的细节；可以给类增加新的方法；
		和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然他们都是同一个类的不同实例，但拥有的变量名称都可能不同。
	访问限制： 可以使代码更加健壮。
		要让内部属性不被外部访问，可以把属性名称前加两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量，只有内部可以访问，外部不可以访问。Python解释器对外把__name变量改成_Student__name或其他变量名（不同Python解释器可能改的不同）.
		在方法中，可以对参数做检查，避免传入无效的参数，故有setter函数
		在Python中，变量名类似__xxx__，双下划线开头结尾，是特殊变量，可以直接访问，不是private变量
		以一个下划线开头的变量，外部可以访问，但约定，最好当成私有变量。
	继承和多态：
		继承：最大的好处就是获得了父类的全部功能；第二个好处就是需要我们队代码做一点改进。继承的另一个好处，多态
		多态：调用方只管调用，不管细节，而当我们新增一个Animal的子类时，只要确保run()方法编写正确，不管原来的代码是如何调用的，这就是
		著名的”开闭原则“：
			对扩展开放:允许新增Animal子类
			对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。
		def run_twice(animal):
    		animal.run()
    		animal.run()

    	>>> run_twice(Animal())
			Animal is running...
			Animal is running...
		>>> run_twice(Cat())
			Cat is running...
			Cat is running...
		静态语言vs动态语言：
			静态语言如java，如需要传入Animal类型，则传入对象必须是这类型或者他的子类，否则无法调用run()方法。
			动态语言，不一定要传入Animal类型或其子类，只要保证传入对象有一个run()方法就可以了。这就是动态语言的“鸭子类型”，不要求严格的继承体系。
			class Timer(object):
    			def run(self):
       				print('Start...')
    获取对象信息：
    	判断对象类型：使用type()函数
    		>>> type('abc')==type('123')
				True
    	判断一个对象是否是函数怎么办？可以使用types模块中定义的常量
    		>>> import types
			>>> def fn():
			...     pass
			...
			>>> type(fn)==types.FunctionType
			True
		对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数
			isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上。
			能用type()判断的基本类型也可以用isinstance()判断：
				>>> isinstance('a', str)
					True
			可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：
				>>> isinstance([1, 2, 3], (list, tuple))
					True
			总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”
		使用dir():
			如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法
			在len()函数内部，它自动去调用该对象的__len__()方法，所以，下面的代码是等价的：
				>>> len('ABC')
					3
				>>> 'ABC'.__len__()
					3
		仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态：
			正确的用法的例子如下：

			def readImage(fp):
    			if hasattr(fp, 'read'):
       				return readData(fp)
  				return None
			假设我们希望从文件流fp中读取图像，我们首先要判断该fp对象是否存在read方法，如果存在，则该对象是一个流，如果不存在，则无法读取。hasattr()就派上了用场。
			请注意，在Python这类动态语言中，根据鸭子类型，有read()方法，不代表该fp对象就是一个文件流，它也可能是网络流，也可能是内存中的一个字节流，但只要read()方法返回的是有效的图像数据，就不影响读取图像的功能。
	实例属性和类属性：
		给实例绑定属性的方法是通过实例变量，或者通过self变量；
		如果是类本身需要绑定一个属性，可以直接在class中定义属性，这种属性是类所有；但类的所有 实例都可以访问到。
		在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。
		>>> class Student(object):
		...     name = 'Student'
		...
		>>> s = Student() # 创建实例s
		>>> print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性
		Student
		>>> print(Student.name) # 打印类的name属性
		Student
		>>> s.name = 'Michael' # 给实例绑定name属性
		>>> print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性
		Michael
		>>> print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问
		Student
		>>> del s.name # 如果删除实例的name属性
		>>> print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了
		Student
		实例属性属于各个实例所有，互不干扰；

		类属性属于类所有，所有实例共享一个属性；

		不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。
		例子：每创建一个实例，count加1
		class Student(object):
			count = 0#每次实例化对象的时候，只需init来为其绑定属性，不会执行类属性部分，即从类属性之后的部分开始运行的，故每次创建实例不会初始化为0
			def __init__(self,name):
				self.__name = name
				Student.count = Student.count + 1#1、init方法是绑定实例的属性用的，不能调用类属性count，故要加Student。
3.面向对象高级编程
	使用__slots__:
		当我们定义了一个class，创建了一个class的实例后，可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。
		但是，给一个实例绑定的方法，对另一个实例是不起作用的，为了给所有实例都绑定方法，可以给class绑定方法。
		>>> def set_score(self, score):
		...     self.score = score
		...
		>>> Student.set_score = set_score
		给class绑定方法后，所有实例均可调用
		>>> s.set_score(100)
		>>> s.score
			100
		>>> s2.set_score(99)
		>>> s2.score
			99
		通常情况下，上面的set_score方法可以直接定义在class中，但动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。
		为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性；
		class Student(object):
    		__slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
    	>>> s = Student() # 创建新的实例
		>>> s.name = 'Michael' # 绑定属性'name'
		>>> s.age = 25 # 绑定属性'age'
		>>> s.score = 99 # 绑定属性'score'
			Traceback (most recent call last):
 			File "<stdin>", line 1, in <module>
			AttributeError: 'Student' object has no attribute 'score'
		使用__slots__变量时，定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。
		除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__
	使用@property:
		负责把一个方法编程属性调用的。广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。
		既能检查参数又能用类似属性这样简单的方式来访问类的变量。
		
		把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作

		还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：
		class Student(object):

   			@property
    		def birth(self):
        		return self._birth

    		@birth.setter
    		def birth(self, value):
        		self._birth = value

    		@property
    		def age(self):
        		return 2015 - self._birth
    多重继承：
    	通过多重继承，一个子类就可以获得多个父类的所有功能。Mixln是一种常见的设计（Java只允许单继承，不能用Mixln的设计）
    	class Dog(Mammal, Runnable):
    		pass
    定制类：
    	__str__   __repr__:
    		怎么才能打印得好看呢？只需要定义好__str__()方法，返回一个好看的字符串就可以了：

			>>> class Student(object):
			...     def __init__(self, name):
			...         self.name = name
			...     def __str__(self):
			...         return 'Student object (name: %s)' % self.name
			...
			>>> print(Student('Michael'))
			Student object (name: Michael)
		__iter__:
			如果一个类想被用于for。。。in 循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误。
		__getitem__:
			表现得像list那样按照下标取出元素，实现__getitem__()方法。
		__getattr__:
			调用类的方法或属性时，不存在时报错，实现这__getattr__()方法后，动态返回一个属性。
			class Student(object):

    			def __init__(self):
       				self.name = 'Michael'

    			def __getattr__(self, attr):
        			if attr=='score':
            			return 99
            >>> s = Student()
			>>> s.name
			'Michael'
			>>> s.score
			99
			可以把一个类的所有属性和方法调用全部动态化处理，这种完全动态调用的特性有什么实际作用呢？作用就是可以针对完全动态的情况作调用。REST API
		__call__:
			任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用
				class Student(object):
    				def __init__(self, name):
        				self.name = name

    				def __call__(self):
        				print('My name is %s.' % self.name)
        		>>> s = Student('Michael')
				>>> s() # self参数不要传入
					My name is Michael.
			，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个Callable对象，比如函数和我们上面定义的带有__call__()的类实例：
			>>> callable(Student())
				True
				通过callable()函数，我们就可以判断一个对象是否是“可调用”对象
	枚举类：
		为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了Enum类来实现这个功能
		from enum import Enum

		Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
		value属性则是自动赋给成员的int常量，默认从1开始计数。

如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：

from enum import Enum, unique

@unique
class Weekday(Enum):
    Sun = 0 # Sun的value被设定为0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6
@unique装饰器可以帮助我们检查保证没有重复值。
		既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量
		Enum可以把一组相关常量定义在一个class中，且class不可变，而且成员可以直接比较。


	元类：
		type()
		动态语言和静态语言最大不同就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。
		要创建一个class对象，type()函数依次传入3个参数：
			1.class的名称；
			2.继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；
			3.class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。
			通过type()函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。

		metaclass:元类
			当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。
			但是如果我们想创建出类呢？那就必须根据metaclass创建出类，所以：先定义metaclass，然后创建类。
			总会遇到需要通过metaclass修改类定义的。ORM就是一个典型的例子
			ORM全称“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作SQL语句。

			metaclass是Python中非常具有魔术性的对象，它可以改变类创建时的行为。
